---
page_title: "Provider: GreyNoise"
description: |-
  The GreyNoise provider is used to interact with GreyNoise resources.
---

# GreyNoise Provider

Use the "greynoise" provider to interact with GreyNoise resources, for example to manage the deployment of sensors and personas.

Authentication is done via the GreyNoise API key which is available on
the [My API Key](https://viz.greynoise.io/account/api-key) in the Visualizer.

The API key can be specified in the configuration via `api_key` or using the environment variable `GN_API_KEY`.

## Example Usage:

```terraform
provider "greynoise" {
  // GN_API_KEY env var is preferred way to provide key
  api_key = "XXX"
}
```

For the Greynoise API key, it is preferred to use the environment variable to avoid hard-coding secrets in the configuration.<!-- schema generated by tfplugindocs -->
## Schema

### Optional

- `api_key` (String, Sensitive) GreyNoise API Key.
- `base_url` (String) GreyNoise API Base URL.

## Complete Example

A complete example using AWS is shown below. In this example an EC2 instance is provisioned and bootstrapped as a GreyNoise sensor. Finally a persona of choice is configured for the sensor.

```terraform
# -- inputs ---
variable "vpc" {
  description = "VPC parameters"
  type = object({
    vpc_id    = string
    subnet_id = string
  })
}

variable "key_pair" {
  description = "Key pair for EC2 instance SSH"
  type = object({
    name             = string
    private_key_file = string
  })
}

# -- main ---
locals {
  name = "greynoise-tf-provider"
}

data "aws_ami" "ubuntu" {
  most_recent = true

  filter {
    name   = "name"
    values = ["ubuntu/images/hvm-ssd/ubuntu-jammy-22.04-amd64-server-*"]
  }

  filter {
    name   = "virtualization-type"
    values = ["hvm"]
  }

  owners = ["099720109477"] # Canonical
}


data "aws_key_pair" "this" {
  key_name           = var.key_pair.name
  include_public_key = true
}

resource "aws_security_group" "this" {
  name        = "${local.name}-sg"
  description = "Security Group for GN sensor"

  vpc_id = var.vpc.vpc_id

  ingress {
    from_port   = 0
    to_port     = 65535
    protocol    = "tcp"
    cidr_blocks = ["0.0.0.0/0"]
    description = "Allow all inbound traffic"
  }

  egress {
    from_port        = 0
    to_port          = 0
    protocol         = "-1"
    cidr_blocks      = ["0.0.0.0/0"]
    ipv6_cidr_blocks = ["::/0"]
    description      = "Allow all egress traffic"
  }
}

resource "aws_instance" "this" {
  ami           = data.aws_ami.ubuntu.id
  subnet_id     = var.vpc.subnet_id
  instance_type = "t2.micro"
  key_name      = data.aws_key_pair.this.key_name
  vpc_security_group_ids = [
    aws_security_group.this.id,
  ]
}

data "greynoise_personas" "rdp" {
  search = "rdp"
  limit  = 1
}

resource "greynoise_sensor_bootstrap" "this" {
  public_ip = aws_instance.this.public_ip

  connection {
    host = aws_instance.this.public_ip
    user = "ubuntu"
    port = 22

    private_key = file(var.key_pair.private_key_file)
  }

  provisioner "remote-exec" {
    inline = [
      # ensure that script can run by waiting for cloud-init to complete
      "cloud-init status --wait > /dev/null",
      self.setup_script,
    ]
  }

  provisioner "remote-exec" {
    inline = [
      self.bootstrap_script,
    ]
    # failure is expected as SSH connection will be lost
    # once bootstrap completes and changes SSH port
    on_failure = continue
  }
}

data "greynoise_sensor" "this" {
  public_ip = aws_instance.this.public_ip
  depends_on = [
    greynoise_sensor_bootstrap.this,
  ]
}

resource "greynoise_sensor_persona" "this" {
  sensor_id  = data.greynoise_sensor.this.id
  persona_id = data.greynoise_personas.rdp.ids[0]
}

# -- outputs --
output "personas" {
  description = "RDP personas"
  value = {
    ids = data.greynoise_personas.rdp.ids
  }
}

output "sensor" {
  description = "Sensor information"
  value = {
    id        = data.greynoise_sensor.this.id
    public_ip = aws_instance.this.public_ip
    ssh_port  = data.greynoise_sensor.this.access_port
  }
}
```
